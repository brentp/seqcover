<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="author" content="Brent Pedersen" />

    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@900&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" rel="stylesheet">
    <link href="https://raw.githack.com/ttskch/select2-bootstrap4-theme/master/dist/select2-bootstrap4.css" rel="stylesheet">

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
        integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/v/bs4/dt-1.10.21/b-1.6.3/b-html5-1.6.3/cr-1.5.2/r-2.2.5/sc-2.0.2/datatables.min.css" />

    <!-- bootstrap and deps -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
        integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
        integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"
        integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI"
        crossorigin="anonymous"></script>

    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>

    <!-- pv range calc could be easily done locally -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protovis/3.3.1/protovis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.1.0/math.min.js"></script>

    <script type="text/javascript"
        src="https://cdn.datatables.net/v/bs4/dt-1.10.21/b-1.6.3/b-html5-1.6.3/cr-1.5.2/r-2.2.5/sc-2.0.2/datatables.min.js"></script>

    <style>
        body {
            height: 100%;
            margin: 0px;
            padding: 0px;
        }

        .container-fluid {
            font-size: .875rem;
        }

        table.dataTable thead th.sorting:after,
        table.dataTable thead th.sorting_asc:after,
        table.dataTable thead th.sorting_desc:after,
        table.dataTable thead th.sorting:before,
        table.dataTable thead th.sorting_asc:before,
        table.dataTable thead th.sorting_desc:before {
            font-family: FontAwesome !important;
        }

        .brand {
            /* padding-top: .75rem;
            padding-bottom: .75rem; */
            font-size: 1.5rem;
            font-family: 'Raleway', sans-serif;
        }
    </style>
</head>

<body>
    <!-- nav -->
    <div class="row bg-dark mx-0 p-1 sticky-top">
        <div class="col-sm-3 col-md-2 col-lg-2"><a class="brand text-white text-decoration-none" href="#">seqcover</a>
        </div>
        <div class="col-sm-12 col-md-10 col-lg-8">
            <div class="input-group flex-nowrap">
                <div class="input-group-prepend">
                    <span class="input-group-text">Region</span>
                </div>
                <select class="form-control" id="region-select"></select>
                <div class="input-group-append">
                    <button class="btn btn-secondary" type="button"><i class="fas fa-caret-left"></i></button>
                </div>
                <div class="input-group-append">
                    <button class="btn btn-secondary" type="button"><i class="fas fa-caret-right"></i></button>
                </div>
            </div>
        </div>
        <div class="col-sm-12 col-md-12 col-lg-2 d-flex align-items-center justify-content-end" id="meta-header">
            <div class="font-weight-light text-light">Genome build <span class="font-weight-bold"
                    id="genome-build">GRCh38</span></div>
        </div>
    </div>

    <main role="main" class="container-fluid">
        <div class="container-fluid p-3">
            <div class="container-fluid p-1">
                <div class="row">
                    <div class="col-12">
                        <div id="gene_plot"></div>
                    </div>
                </div>
                <div class="row p-3">
                    <div class="table-responsive">
                        <table id="stats_table" class="table table-sm table-hover display nowrap w-100"></table>
                    </div>
                </div>
                <div class="row pt-5">
                    <div class="col-6" id="depth_dist_plot">
                    </div>
                    <div class="col-6" id="proportion_plot">
                    </div>
                </div>
            </div>
    </main>
</body>

<script src="o.js"></script>

<script>

    var nan = NaN; // hack to support json dumped with NaN values.
    const gene_plot_height = 500
    const plot_colors = ["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"]

    /*
    ------------------------------------------------------------------------------------------------------------------
                                                      Plot Functions
    ------------------------------------------------------------------------------------------------------------------
    */

    //by base depth plot layout
    function get_gene_plot_layout(gene) {

        var mid = Math.round(gene.plot_coords.x.length / 2)

        var layout = {
            grid: {
                rows: 3,
                columns: 1,
            },
            autosize: true,
            height: gene_plot_height,
            margin: { t: 10, r: 0, b:30 },
            xaxis: {
                tickmode: "array",
                tickvals: [gene.plot_coords.x[0], gene.plot_coords.x[mid], gene.plot_coords.x[gene.plot_coords.x.length - 10]],
                ticktext: [gene.plot_coords.g[0], gene.plot_coords.g[mid], gene.plot_coords.g[gene.plot_coords.x.length - 10]],
                // title: "Chromosome " + String(gene.unioned_transcript.chr).replace("chr", "")
            },
            yaxis: {
                title: "Depth",
                domain: [0.55, 1]
            },
            yaxis2: {
                title: "Merged<br>Transcripts",
                range: [0, 2],
                showlegend: false,
                zeroline: false,
                showticklabels: false,
                ticktext: gene.unioned_transcript.transcript,
                domain: [0.4, 0.55],

            },
            yaxis3: {
                range: [0, 2],
                zeroline: false,
                showlegend: false,
                domain: [0.0, 0.40]
            },
            hovermode: 'closest',
            showlegend: false,
            legend: {
                xanchor: "right",
                yanchor: "top",
                y: 1,
                x: 1,
                orientation: "h",
                borderwidth: 1,
                bordercolor: '#eeeeee'
            },
        };

        return (layout)

    };


    //Get a by position trace per sample of depth
    function get_by_position_depth_trace(gene) {

        var traces = [];

        for (sample in gene.plot_coords.depths) {
            var dp = gene.plot_coords.depths[sample]
            dp = dp.map(function (v) { return v < -1000 ? NaN : v })

            var trace = {
                x: gene.plot_coords.x, text: gene.plot_coords.g, y: dp,
                type: 'scatter', mode: 'lines', name: sample, line: { width: 1 },
                hovertemplate: '<b>position</b>:%{text}<br><b>depth</b>:%{y}<br>(debug) x: %{x}',
                hoverinfo: "text",
                yaxis: "y",
            };

            traces.push(trace);
        };

        return (traces)

    };


    //Get the unioned transcript shapes
    function get_unioned_transcript_shapes(gene) {

        let middle = 1
        let exonOffset = 0.25
        let cdsOffset = 0.5
        let textOffset = 0.7
        var shapes = [];
        var tr = gene.unioned_transcript;
        let strandArray = [];

        //Add CDS Region
        shapes.push({ type: "rect", x0: tr.cdsstart, x1: tr.cdsend, y0: middle - cdsOffset, y1: middle + cdsOffset, opacity: 0.5, fillcolor: "deepskyblue", line: { color: "deepskyblue" }, yref: "y2" })

        //Add region type text
        strandArray.push({ x: (tr.cdsstart + ((tr.cdsend - tr.cdsstart) / 2)), y: middle + textOffset, text: "Coding Region", font: { color: "deepskyblue", font: 20 }, showarrow: false, yref: "y2" })

        //Add Left Non CDS Region
        if (tr.cdsstart < tr.txend) {
            shapes.push({ type: "rect", x0: tr.txstart, x1: tr.cdsstart, y0: middle - cdsOffset, y1: middle + cdsOffset, opacity: 0.5, fillcolor: "darkviolet", line: { color: "darkviolet" }, yref: "y2" })

            //Add region type text
            strandArray.push({ x: (tr.txstart + (tr.cdsstart - tr.txstart) / 2), y: middle + textOffset, text: "Non-Coding Region", font: { color: "darkviolet", font: 20 }, showarrow: false, yref: "y2" })
        }
        if (tr.cdsend < tr.txend) {
            shapes.push({ type: "rect", x0: tr.cdsend, x1: tr.txend, y0: middle - cdsOffset, y1: middle + cdsOffset, opacity: 0.5, fillcolor: "darkviolet", line: { color: "darkviolet" }, yref: "y2" })

            //Add region type text
            strandArray.push({ x: (tr.cdsend + (tr.txend - tr.cdsend) / 2), y: middle + textOffset, text: "Non-Coding Region", font: { color: "darkviolet", font: 20 }, showarrow: false, yref: "y2" })
        }

        //ADD transcript
        shapes.push({ type: "line", x0: tr.txstart, x1: tr.txend, y0: middle, y1: middle, line_color: "black", yref: "y2" })
        //ADD exons
        tr.position.forEach(p => shapes.push({
            type: "rect", x0: p[0], x1: p[1], y0: middle - exonOffset, y1: middle + exonOffset,
            fillcolor: "darkgrey", line: { color: "black" }, yref: "y2"
        }))
        //Strand info
        let strand_marker = tr.strand > 0 ? ">" : "<";
        let max_index = tr.position.length - 1
        let x_values = []
        let y_values = []
        let txStrand = tr.strand > 0 ? "+" : "-"
        let customData = []
        for (index in tr.position) {

            //Get x and y values for hover data
            let startPos = tr.position[parseInt(index)][0]
            let endPos = tr.position[parseInt(index)][1]

            x_values.push(startPos + ((endPos - startPos) / 2))
            y_values.push(middle)

            //Get hover data
            let gTxStart = gene.plot_coords.g[binary_search(gene.plot_coords.x, tr.txstart)]
            let gTxEnd = gene.plot_coords.g[binary_search(gene.plot_coords.x, tr.txend)]
            let gStartPos = gene.plot_coords.g[binary_search(gene.plot_coords.x, startPos)]
            let gEndPos = gene.plot_coords.g[binary_search(gene.plot_coords.x, endPos)]
            customData.push({ "symbol": gene.symbol, "txStart": gTxStart, "txEnd": gTxEnd, "exonStart": gStartPos, "exonEnd": gEndPos, "strand": txStrand })

            //Get strand annotation text
            if (parseInt(index) == max_index) {
                break
            };

            let nextStartPos = tr.position[(parseInt(index) + 1)][0]
            let xPos = endPos + ((nextStartPos - endPos) / 2)

            strandArray.push({ x: xPos, y: middle + 0.01, text: strand_marker, font: { color: "black", size: 16 }, opacity: 0.7, showarrow: false, yref: "y2" })

        };

        //Format = transcript id, strand, txstart, txend, cdsstart, cdsend, exon/utr start, exon/utr end, exon number or utr type
        let trace = {
            x: x_values, y: y_values,
            type: 'scatter', mode: 'markers', customdata: customData, name: "Merged Transcript",
            opacity: 0.0, showlegend: false, yaxis: "y2", marker: { color: "skyblue", size: 15 },
            hovertemplate: '<b>Gene</b>: %{customdata.symbol}<br><b>Strand</b>: %{customdata.strand}<br><b>TX Start</b>: %{customdata.txStart}<br><b>TX End</b>: %{customdata.txEnd}<br><b>Merged Exon Start</b>: %{customdata.exonStart}<br><b>Merged Exon End</b>: %{customdata.exonEnd}<br>',
        };

        return ({ "shapes": shapes, "strand_annotation": strandArray, "trace": trace })

    };


    function binary_search(A, v) {
        var result = 0;
        var j = A.length
        while (j != 0) {
            let step = j >> 1
            let pos = result + step;
            if (A[pos] < v) {
                result = pos + 1
                j -= step + 1
            } else {
                j = step
            }

        }
        return result
    }


    //Get a list of transcript information to use as a custoomdata imput for plotly hover data
    function get_custom_data(transcript, exonStart, exonEnd, exonNumber, cdsExon, feature, xs, gposition_list) {

        //Format = transcript id, strand, txstart, txend, cdsstart, cdsend, exon/utr start, exon/utr end, exon number or utr type
        custdata = {
            "tx_id": transcript.transcript,
            "strand": transcript.strand > 0 ? "+" : "-",
            "tx_start": gposition_list[binary_search(xs, transcript.txstart)],
            "tx_end": gposition_list[binary_search(xs, transcript.txend)],
            "cds_start": gposition_list[binary_search(xs, transcript.cdsstart)],
            "cds_end": gposition_list[binary_search(xs, transcript.cdsend)],
            "exon_start": gposition_list[binary_search(xs, exonStart)],
            "exon_end": gposition_list[binary_search(xs, exonEnd)],
            "exon_count": exonNumber,
            "CDS": cdsExon,
            "Feature": feature
        }

        return (custdata)

    };

    //Get the transcript shapes for the current region
    function get_transcript_shapes(gene) {

        let symbol = gene.symbol
        let top = 10;
        let bottom = 8;
        let exonOffset = 0.25;
        let utrOffset = 0.1;
        let shapes = [];
        let tick_labels = [];
        let tick_vals = [];
        let strandArray = [];
        let x_values = []
        let y_values = []
        let customData = []
        let text_symbol = []

        for (transcript of gene.transcripts) {

            // Transcript
            shapes.push({
                type: "line", x0: transcript.txstart, x1: transcript.txend,
                y0: bottom + 1, y1: bottom + 1, line_color: "black", yref: "y3"
            })

            //Strand info
            let strand_interval = Math.round((transcript.txend - transcript.txstart) / 20)
            let strand_marker = transcript.strand > 0 ? ">" : "<";
            for (i = transcript.cdsstart; i < transcript.cdsend; i++) {
                if (i % strand_interval == 0) {
                    strandArray.push({ x: i, y: bottom + 1.01, text: strand_marker, font: { color: "black", size: 16 }, opacity: 0.7, showarrow: false, yref: "y3" })
                };
            };


            //Get Start UTRs
            let utr1 = {
                type: "rect", x0: transcript.txstart, x1: transcript.cdsstart,
                y0: bottom + (1 - utrOffset), y1: bottom + (1 + utrOffset),
                line_color: "black", fillcolor: "cyan", yref: "y3"
            }


            //Get End UTR
            let utr2 = {
                type: "rect", x0: transcript.cdsend, x1: transcript.txend,
                y0: bottom + (1 - utrOffset), y1: bottom + (1 + utrOffset),
                line_color: "cyan", fillcolor: "cyan", yref: "y3"
            }


            // If CDS region is at the end of the transcript, the whole region is a UTR
            if (transcript.txend <= transcript.cdsstart) {

                //Add UTR info to customData
                ///UTR1
                customData.push(get_custom_data(transcript, transcript.txstart,
                    transcript.cdsstart, "UTR", "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g))
                text_symbol.push(symbol)

                //Add UTRs to shapes
                ///UR1
                shapes.push(utr1)

                // Add UTR plot coordinates for hover info
                ///UTR1
                x_values.push((transcript.txstart + ((transcript.cdsstart - transcript.txstart) / 2)))
                y_values.push(bottom + 1)

                // IF CDS regions ends at the beginning of the transcript, the whole region is a UTR
            } else if (transcript.txstart >= transcript.cdsend) {

                //Add UTR info to customData
                ///UTR2
                customData.push(get_custom_data(transcript, transcript.cdsend,
                    transcript.txend, "UTR", "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g))
                text_symbol.push(symbol)

                //Add UTRs to shapes
                ///UTR2
                shapes.push(utr2)

                // Add UTR plot coordinates for hover info
                ///UTR2
                x_values.push((transcript.cdsend + ((transcript.txend - transcript.cdsend) / 2)))
                y_values.push(bottom + 1)

            } else {

                //Add UTR info to customData
                ///UTR1
                customData.push(get_custom_data(transcript, transcript.txstart,
                    transcript.cdsstart, transcript.strand > 0 ? "5'-UTR" : "3'-UTR",
                    "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g))
                text_symbol.push(symbol)
                ///UTR2
                customData.push(get_custom_data(transcript, transcript.cdsend,
                    transcript.txend, transcript.strand > 0 ? "3'-UTR" : "5'-UTR",
                    "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g))
                text_symbol.push(symbol)

                //Add UTRs to shapes
                ///UR1
                shapes.push(utr1)
                ///UTR2
                shapes.push(utr2)

                // Add UTR plot coordinates for hover info
                ///UTR1
                x_values.push((transcript.txstart + ((transcript.cdsstart - transcript.txstart) / 2)))
                y_values.push(bottom + 1)
                ///UTR2
                x_values.push((transcript.cdsend + ((transcript.txend - transcript.cdsend) / 2)))
                y_values.push(bottom + 1)

            };

            //Sort exon positions
            exon_2d_array = transcript.position.sort(function (a, b) { return a[0] - b[0] })

            //Count cds exons
            let cdsExonCount = 0
            for (index in exon_2d_array) {

                let exonPos = transcript.position[index]

                if (exonPos[1] > transcript.cdsstart & exonPos[0] < transcript.cdsend) { cdsExonCount += 1 };

            };

            // Get exon numbers
            let exonNumbers = transcript.strand > 0 ? pv.range(1, cdsExonCount + 1) : pv.range(cdsExonCount, 0, -1)
            let exonNumberOffset = 0

            //Add exon shapes
            for (index in exon_2d_array) {

                let exonPos = exon_2d_array[index]

                //If exon in CDS region
                if (exonPos[1] > transcript.cdsstart & exonPos[0] < transcript.cdsend) {

                    //If exon start is before the CDS start
                    /// Half coding exon
                    if (exonPos[0] < transcript.cdsstart) {

                        let nonCdsExonStart = exonPos[0]
                        let cdsExonStart = transcript.cdsstart
                        let exonEnd = exonPos[1]

                        //Add exon to shapes
                        /// Non CDS exon Portion
                        shapes.push({
                            type: "rect", x0: nonCdsExonStart, x1: cdsExonStart, y0: bottom + (1 - exonOffset),
                            y1: bottom + (1 + exonOffset), opacity: 0.4, line_color: "black", fillcolor: "grey", yref: "y3"
                        })
                        //CDS exon poriton
                        shapes.push({
                            type: "rect", x0: cdsExonStart, x1: exonEnd, y0: bottom + (1 - exonOffset),
                            y1: bottom + (1 + exonOffset), line_color: "black", fillcolor: "black", yref: "y3"
                        })

                        //Add exon info to customData
                        customData.push(get_custom_data(transcript, nonCdsExonStart, exonEnd,
                            exonNumbers[(parseInt(index) - exonNumberOffset)], "Partial", "Partial Coding Exon", gene.plot_coords.x, gene.plot_coords.g))
                        text_symbol.push(symbol)

                        // Add exon plot coordinates for hover info
                        x_values.push(cdsExonStart)
                        y_values.push(bottom + 1)


                        // If Exon end is after CDS end
                        /// Half coding exon
                    } else if (exonPos[1] > transcript.cdsend) {

                        let exonStart = exonPos[0]
                        let cdsExonEnd = transcript.cdsend
                        let nonCdsExonEnd = exonPos[1]

                        //Add exon to shapes
                        /// CDS exon Portion
                        shapes.push({
                            type: "rect", x0: exonStart, x1: cdsExonEnd, y0: bottom + (1 - exonOffset),
                            y1: bottom + (1 + exonOffset), line_color: "black", fillcolor: "black", yref: "y3"
                        })
                        /// Non CDS exon poriton
                        shapes.push({
                            type: "rect", x0: cdsExonEnd, x1: nonCdsExonEnd, y0: bottom + (1 - exonOffset),
                            y1: bottom + (1 + exonOffset), opacity: 0.4, line_color: "black", fillcolor: "grey", yref: "y3"
                        })

                        //Add exon info to customData
                        customData.push(get_custom_data(transcript, exonStart, nonCdsExonEnd,
                            exonNumbers[(parseInt(index) - exonNumberOffset)], "Partial", "Partial Coding Exon", gene.plot_coords.x, gene.plot_coords.g))
                        text_symbol.push(symbol)

                        // Add exon plot coordinates for hover info
                        x_values.push(cdsExonEnd)
                        y_values.push(bottom + 1)

                        // IF exon is completely contained within the CDS region
                        //Full coding exon
                    } else {

                        let exonstart = exonPos[0]
                        let exonend = exonPos[1]

                        //Add exon to shapes
                        shapes.push({
                            type: "rect", x0: exonstart, x1: exonend, y0: bottom + (1 - exonOffset),
                            y1: bottom + (1 + exonOffset), line_color: "black", fillcolor: "black", yref: "y3"
                        })

                        //Add exon info to customData
                        customData.push(get_custom_data(transcript, exonstart, exonend,
                            exonNumbers[(parseInt(index) - exonNumberOffset)], "True", "Coding Exon", gene.plot_coords.x, gene.plot_coords.g))
                        text_symbol.push(symbol)

                        // Add exon plot coordinates for hover info
                        x_values.push((exonstart + ((exonend - exonstart) / 2)))
                        y_values.push(bottom + 1)
                    }


                    // If exon not in CDS region
                    //Non CDS exon
                } else {

                    exonNumberOffset += 1

                    let exonstart = exonPos[0]
                    let exonend = exonPos[1]

                    //Add exon to shapes
                    shapes.push({
                        type: "rect", x0: exonstart, x1: exonend, y0: bottom + (1 - exonOffset),
                        y1: bottom + (1 + exonOffset), opacity: 0.4, line_color: "black", fillcolor: "grey", yref: "y3"
                    })

                    //Add exon info to customData
                    customData.push(get_custom_data(transcript, exonstart, exonend,
                        "NA", "False", "Non-Coding Exon", gene.plot_coords.x, gene.plot_coords.g))
                    text_symbol.push(symbol)

                    // Add exon plot coordinates for hover info
                    x_values.push((exonstart + ((exonend - exonstart) / 2)))
                    y_values.push(bottom + 1)

                };

            };

            //Get tick labels
            tick_labels.push(transcript.transcript)
            tick_vals.push(bottom + 1)

            //update bottom
            bottom = bottom - 1
        };

        //Format = transcript id, strand, txstart, txend, cdsstart, cdsend, exon/utr start, exon/utr end, exon number or utr type
        let trace = {
            x: x_values, y: y_values, text: text_symbol,
            type: 'scatter', mode: 'markers', customdata: customData, name: "Transcripts",
            opacity: 0.0, showlegend: false, yaxis: "y3", marker: { color: "darkcyan", size: 15 },
            hovertemplate: '<b>Gene</b>: %{text}<br><b>Transcript ID</b>: %{customdata.tx_id}<br><b>Strand</b>: %{customdata.strand}<br><b>Feature</b>: %{customdata.Feature}<br><b>Start Position</b>: %{customdata.exon_start}<br><b>End Position</b>: %{customdata.exon_end}<br><b>Coding Region</b>: %{customdata.CDS}<br><b>CDS Exon Number</b>: %{customdata.exon_count}<br>',
        };

        return ({ "shapes": shapes, "top": top, "bottom": bottom, "tick_labels": tick_labels, "tick_vals": tick_vals, "strand_annotation": strandArray, "trace": trace })

    };

    //Get descriptive stats info for stats table
    function get_stats_table(gene, low_depth = 10) {

        var dataRows = []
        var columnNames = [
            { "title": "Sample" },
            { "title": "Mean Depth" },
            { "title": "Median Depth" },
            { "title": "STD" },
            { "title": "Min Depth" },
            { "title": "Max Depth" },
            { "title": "Low Coverage Sites (<=" + low_depth + ")" }
        ]

        for (sample in gene.plot_coords.depths) {

            // Depths
            let dp = gene.plot_coords.depths[sample]
            dp = dp.filter(value => value > -1000);

            //Get depth descriptive statistics
            let dp_min = Math.min(...dp)
            let dp_max = Math.max(...dp)
            let dp_mean = math.round(math.mean(dp), 3)
            let dp_median = math.median(dp)
            let dp_std = math.round(math.std(dp), 3)
            let dp_low = math.sum(dp.map(function (v) { return v <= low_depth ? 1 : 0 }))

            dataRows.push([sample, dp_mean, dp_median, dp_std, dp_min, dp_max, dp_low])
        };
        return ({ rowData: dataRows, colNames: columnNames })
    };


    //Get the traces for each sample depth distribution
    function get_depth_distribution_traces(gene) {

        let traces = []
        let group_min_dp = 1000
        let group_max_dp = 0

        for (sample in gene.plot_coords.depths) {

            // Depths
            let dp = gene.plot_coords.depths[sample]

            //Convert null values to NaN
            dp = dp.filter(value => value > -1000);

            //min and max
            let dp_min = Math.min(...dp)
            group_min_dp = dp_min < group_min_dp ? dp_min : group_min_dp
            let dp_max = Math.max(...dp)
            group_max_dp = dp_max > group_max_dp ? dp_max : group_max_dp

            // X and Y values
            let x_values = pv.range(dp_min, dp_max + 1)
            let y_values = new Array(x_values.length).fill(0)

            //Get y values
            //index of depth in x_values = depth - dp_min
            dp.forEach(depth => y_values[(depth - dp_min)] += 1)


            let trace = {
                x: x_values, y: y_values, mode: "lines",
                name: sample, line: { width: 1 },
                hovertemplate: "<b>Depth</b>:%{x}<br><b>Count</b>:%{y}"
            }

            traces.push(trace)
        };

        return ({ "traces": traces, "min": group_min_dp, "max": group_max_dp })

    };


    //Get the depth distribution layout
    function get_depth_distribution_layout(xaxis_min = 0, xaxis_max = 100) {

        var layout = {
            autosize: true,
            title: "Depth Distribution per Sample",
            xaxis: {
                title: "Depth",
                range: [xaxis_min, xaxis_max]
            },
            yaxis: {
                title: "Count",
                domain: [0.0, 0.9],
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                xanchor: "right",
                yanchor: "top",
                y: 1,
                x: 1,
                orientation: "h",
                borderwidth: 1,
                bordercolor: '#eeeeee'
            },
        };
        return (layout)
    };


    //per Sample depth proportion traces
    function get_proportion_trace(gene) {

        let traces = []

        for (sample in gene.plot_coords.depths) {

            // Depths
            dp = dp.filter(value => value > -1000);

            let depth_map = {}
            let depth_values = new Set()
            let dp_count = 0
            //get the number of
            for (depth of dp) {

                dp_count += 1

                depth_values.add(depth)

                if (!(depth in depth_map)) {
                    depth_map[depth] = 1

                } else {
                    depth_map[depth] += 1
                };
            };

            let x_values = []
            let y_values = []
            let counter = 0
            //Calculate proportion scores
            for (key of [...depth_values].sort(function (a, b) { return b - a })) {

                //increment counter
                counter += depth_map[key]

                //Add x and y valuess
                x_values.push(key)
                y_values.push(counter / dp_count)

            };

            let trace = {
                x: x_values, y: y_values, mode: "lines",
                name: sample, line: { width: 1 },
                hovertemplate: "<b>Depth</b>:%{x}<br><b>Proportion</b>:%{y}"
            }

            traces.push(trace)
        };

        return (traces)
    };


    //by proprotion plot layout
    function get_proportion_layout() {

        var layout = {
            autosize: true,
            title: "Depth Proportion per Sample",
            xaxis: {
                title: "Depth"
            },
            yaxis: {
                title: "Proportion",
                domain: [0.0, 0.9],
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                xanchor: "right",
                yanchor: "top",
                y: 1,
                x: 1,
                orientation: "h",
                borderwidth: 1,
                bordercolor: '#eeeeee'
            },
        };
        return (layout)
    };


    /*
    ------------------------------------------------------------------------------------------------------------------
                                                     Plot Controllers
    ------------------------------------------------------------------------------------------------------------------
    */

    //Per base depth plot with transcript annotations
    function plot_per_base_depth(gene) {

        //Get gene specific layout
        plot_gene_layout = get_gene_plot_layout(gene)

        //Get gene specific depth traces
        by_position_depth_traces = get_by_position_depth_trace(gene)


        // get unionized transcript shapes
        unioned_transcript_shapes = get_unioned_transcript_shapes(gene)
        by_position_depth_traces.push(unioned_transcript_shapes.trace)

        // Get per transcript annotation shapes
        transcript_map = get_transcript_shapes(gene)
        by_position_depth_traces.push(transcript_map.trace)

        //Add shapes to layout
        plot_gene_layout.shapes = unioned_transcript_shapes.shapes.concat(transcript_map.shapes)

        //Adjuste subplot 3 yaxis ranges based on the number of annotated  transcripts
        plot_gene_layout.yaxis3.range = [transcript_map.bottom, transcript_map.top]

        //Add subplot 3 yaxis tick labels (transcript ids)
        plot_gene_layout.yaxis3.tickvals = transcript_map.tick_vals
        plot_gene_layout.yaxis3.ticktext = transcript_map.tick_labels

        //Add subplot 3 strand annotations
        plot_gene_layout.annotations = transcript_map.strand_annotation.concat(unioned_transcript_shapes.strand_annotation)

        //Plot by base depth
        Plotly.newPlot("gene_plot", by_position_depth_traces, plot_gene_layout)

    };


    //Add a jQuery data table with descriptive stats
    function plot_stats_table(gene) {

        //Remove previous data table if it exists
        if ($.fn.DataTable.isDataTable('#stats_table')) {
            let table = $('#stats_table').DataTable()
            table.destroy();
        };

        //Get row data and column names
        rows_and_columns = get_stats_table(gene)

        //Create data table
        jQuery("#stats_table").DataTable({
            destory: true,
            data: rows_and_columns["rowData"],
            columns: rows_and_columns["colNames"],
            paging: true,
            scroller: true,
            scrollY: '400',
            scrollX: true,
            scrollCollapse: true,
        });

    };


    //Depth Distribution plot using per depth count
    function plot_depth_distribution(gene) {

        //Get depth distribution plot trace per sample
        var depth_map = get_depth_distribution_traces(gene)

        //Get the plot layout for the depth plot
        var depth_dist_layout = get_depth_distribution_layout(depth_map.min - 5, depth_map.max + 5)

        Plotly.newPlot("depth_dist_plot", depth_map.traces, depth_dist_layout)

    };



    /*
    ------------------------------------------------------------------------------------------------------------------
                                                     Event Handling
    ------------------------------------------------------------------------------------------------------------------
    */

    // Controller function for generating gene/region specific plots
    function generate_plots(selected_region) {

        let selected_gene = plot_data[selected_region]

        //Plot per base depths
        plot_per_base_depth(selected_gene)

        //Add a descriptive statistics table
        plot_stats_table(selected_gene)

        //Plot depth distribution distrubtion
        plot_depth_distribution(selected_gene)

    };


    //Load first region
    jQuery(document).ready(function () {
        let regions = []
        for (const [i, pd] of plot_data.entries()) {
            console.log('%d: %s', i, pd)
            let region = `${pd.symbol} ${pd.unioned_transcript.chr}:${pd.plot_coords.g[0]}-${pd.plot_coords.g[pd.plot_coords.g.length - 1]}`
            regions.push({ "id": i, "text": region })
        }
        generate_plots(0)
        // n = gene symbol, v = the index
        $("#region-select").select2({
            data: regions,
            selectOnClose: true,
            width: 'resolve',
            theme: 'bootstrap4',
            width: $(this).data('width') ? $(this).data('width') : $(this).hasClass('w-100') ? '100%' : 'style'
        })

        // register handler
        $('#region-select').on('change', function () {
            // untested (https://select2.org/programmatic-control/retrieving-selections)
            generate_plots(this.value)
        })

    })
</script>

</body>
</html>
