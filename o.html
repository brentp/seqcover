<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="author" content="Brent Pedersen" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/css/selectize.bootstrap3.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/js/standalone/selectize.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protovis/3.3.1/protovis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.1.0/math.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/dt-1.10.20/r-2.2.3/sc-2.0.1/sl-1.3.1/datatables.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/datatables/1.10.21/js/jquery.dataTables.min.js"></script>
    <style>

    .big_div {
          height: 80vh;
        }

    .med_div {
          height: 45vh;
        }

    .cdsSquare {
      height: 15px;
      width: 30px;
      background-color: #000000;

    }

    .nonCdsSquare {
      height: 15px;
      width: 30px;
      border: 1px solid #000000;
      background-color: #808080;
      opacity: 0.25;
    }

    .utrSquare {
      height: 10px;
      width: 25px;
      border: 1px solid #000000;
      background-color: #00FFFF;
    }
    
    html,body { height: 100%; margin: 0px; padding: 0px; }
    .form-control.selectize-control {
        padding: 5px 6px 0px;
        height: unset !important;
    }
    .remove-single {
        color: gray !important;
        top: -1px !important;
        font-size: 20px !important;
    }
    </style>
</head>

<body>
    <h1> SEQCOVER </h1>
        <div class="container-fluid p-3">
        <div class="row pt-3 pl-3">
            <div class="form-group", id="regionfilter">
                <label for="regionfilter">Gene/Region Selection</label>
            </div>
        </div>
    <hr>
    <div class="container-fluid p-1">
        <div class="row pt-3">
            <div class="col-6">
                <h4> Region: </h4>
                <h5 id="region_header">REGION: </h5>
            </div>
            <div class="col-6">
               <h5>Gene Description:</h5>
               <p id="gene_description">Description</p> 
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <div class=med_div id="gene_plot"></div>
            </div>
        </div>
        <div class="row pb-3">
            <div class="col-sm-3">
            </div>
            <div class="col-sm-4">
                <button type="button" class="btn btn-outline-primary" data-toggle="button" id="showTranscripts" aria-pressed="false" autocomplete="false">
                  Show Transcripts
                </button>
            </div>
            <div class="col-sm-1">
                <h6> Included Exons:</h6>
            </div>
            <div class="col-sm-1">
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" id="cdsExons" disabled checked></input>
                  <label class="form-check-label" for="inlineCheckbox1">CDS</label>
                </div>
                <div class="cdsSquare"></div>
            </div>
            <div class="col-sm-1">
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" id="utrs"></input>
                  <label class="form-check-label" for="inlineCheckbox2">UTR</label>
                </div>
                <div class="utrSquare"></div>
            </div>
            <div class="col-sm-2">
                <div class="form-check form-check-inline">
                  <input class="form-check-input" type="checkbox" id="nonCdsExons"></input>
                  <label class="form-check-label" for="inlineCheckbox2">Non-CDS</label>
                </div>
                <div class="nonCdsSquare"></div>
            </div>
        </div>
    </div>
    <div class="container-fluid p-1">
        <div class="row">
            <div class="col-sm-1"></div>
            <div class="col-sm-10">
                <hr>
            </div>
        </div>
        <div class="row pt-3">
            <div class="col-2"></div>
            <div class="col-8">
                <table id="stats_table"></table>
            </div>
            <div class="col-2"></div>
        </div>
        <div class="row pt-5">
            <div class="col-6" id="depth_dist_plot">
            </div>
            <div class="col-6" id="proportion_plot">
            </div>
        </div>
    </div>
</body>

<script src="o.js"></script>

<script>

    /*
    ------------------------------------------------------------------------------------------------------------------
                                                        SETUP 
    ------------------------------------------------------------------------------------------------------------------
    */

    //Global Variables
    var nan = NaN; // hack to support json dumped with NaN values.
    var initalIndex = 0
    var currentRegion = "";
    var nonCdsChecked = false;
    var utrsChecked = false;
    var showTranscripts = false;

    //Get gene/region names and add them to the available regions form 
    var region_index_map = {};
    var select = $('<select class="form-control" id="regionselect"></select>');
    var index_map = {};
    for (index in plot_data) {

        //Get region gene info
        var symbol = plot_data[index].symbol;
        var chrom = plot_data[index].unioned_transcript.chr;
        var genomic_positions = plot_data[index].plot_coords.g;
        var start = Math.min.apply(null,genomic_positions.filter(Boolean));
        var end = Math.max(...genomic_positions);

        //Get region string
        var region_string = symbol + " "+ chrom + ":" + start + "-" + end

        //Store the index of the region in the plot data object.
        region_index_map[region_string] = index 

    };

    //Create sorted select list
    let ind = 0
    for (region of Object.keys(region_index_map).sort()) {
        
        //Get the first sorted region for inital display
        if (ind == 0) {initalIndex = region_index_map[region]}

        //Add region to select options
        var option = $("<option>" + region + "</option>");
        select.append(option)

        ind += 1

    };



    //Add new select options to regionfilter div
    $("#regionfilter").append(select);


    /*
    ------------------------------------------------------------------------------------------------------------------
                                                      Plot Functions 
    ------------------------------------------------------------------------------------------------------------------
    */

    //by base depth plot layout
    function get_gene_plot_layout(gene) {

        var mid = Math.round(gene.plot_coords.x.length / 2)

        var layout = {
            grid: {
                rows: 3,
                columns: 1,
            },
            autosize: true,
            margin: {t: 30, pad: 0, l: 150},
            xaxis: {
                tickmode: "array",
                tickvals: [gene.plot_coords.x[0], gene.plot_coords.x[mid], gene.plot_coords.x[gene.plot_coords.x.length - 10]],
                ticktext: [gene.plot_coords.g[0], gene.plot_coords.g[mid], gene.plot_coords.g[gene.plot_coords.x.length - 10]],
                title: "Chromosome " + String(gene.unioned_transcript.chr).replace("chr","")
            },
            yaxis: {
                title: "Depth",
                domain: [0.3,0.90]
            },
            yaxis2: {
                title: "Merged<br>Transcripts",
                range: [0,2],
                showlegend: false,
                zeroline: false,
                showticklabels: false,
                ticktext: gene.unioned_transcript.transcript,
                domain: [0.0,0.3],

            },

            hovermode: 'closest',
            showlegend: true,
            legend: {
                xanchor: "right",
                yanchor: "top",
                y: 1,
                x: 1,
                orientation: "h",
                borderwidth: 1,
                bordercolor: '#eeeeee'
            },
        };


        //Add the 3rd layout if show transcripts is on
        if (showTranscripts) {
            
            //Update yaxis domains
            layout.yaxis.domain = [0.55,0.90] 
            layout.yaxis2.domain =  [0.4,0.55]

            //Add 3rd axis
            layout["yaxis3"] = {range: [0,2],
                                zeroline: false,
                                showlegend: false,
                                domain: [0.0,0.40]
                                }
        };


        return(layout)

    };


    //Get a by position trace per sample of depth 
    function get_by_position_depth_trace(gene) {

        var traces = [];

        for (sample in gene.plot_coords.depths) {
            var dp = gene.plot_coords.depths[sample]
            dp = dp.map(function(v) { return v < -1000 ? NaN : v})

            var trace = {x: gene.plot_coords.x, text: gene.plot_coords.g, y: dp, 
                type: 'scatter', mode:'lines', name: sample, line: {width: 1},
                hovertemplate: '<b>position</b>:%{text}<br><b>depth</b>:%{y}<br>(debug) x: %{x}',
                hoverinfo:"text",
                yaxis: "y",
            };

            traces.push(trace);
        };

        return(traces)

    };


    //Get the unioned transcript shapes
    function get_unioned_transcript_shapes(gene) {
        
        let middle = 1
        let exonOffset = 0.25
        let cdsOffset = 0.5
        let textOffset = 0.7
        var shapes = [];
        var tr = gene.unioned_transcript;
        let strandArray = [];

        //Add CDS Region
        shapes.push({type: "rect", x0: tr.cdsstart, x1: tr.cdsend, y0: middle - cdsOffset, y1: middle + cdsOffset, opacity: 0.5, fillcolor: "deepskyblue", line: {color: "deepskyblue"}, yref: "y2"})

        //Add region type text
        strandArray.push({x: (tr.cdsstart + ((tr.cdsend - tr.cdsstart) / 2)), y: middle + textOffset, text: "Coding Region", font: {color :"deepskyblue", font: 20}, showarrow: false, yref: "y2"})

        //Add Left Non CDS Region 
        if (tr.cdsstart < tr.txend) {
            shapes.push({type: "rect", x0: tr.txstart, x1: tr.cdsstart, y0: middle - cdsOffset, y1: middle + cdsOffset, opacity: 0.5, fillcolor: "darkviolet", line: {color: "darkviolet"}, yref: "y2"})
            
            //Add region type text
            strandArray.push({x: (tr.txstart + (tr.cdsstart - tr.txstart) / 2), y: middle + textOffset, text: "Non-Coding Region", font: {color :"darkviolet", font: 20}, showarrow: false, yref: "y2"})
        }
        //Add Right Non Cds Region
        if (tr.cdsend < tr.txend) {
            shapes.push({type: "rect", x0: tr.cdsend, x1: tr.txend, y0: middle - cdsOffset, y1: middle + cdsOffset, opacity: 0.5, fillcolor: "darkviolet", line: {color: "darkviolet"}, yref: "y2"})

            //Add region type text
            strandArray.push({x: (tr.cdsend + (tr.txend - tr.cdsend) / 2 ) , y: middle + textOffset, text: "Non-Coding Region", font: {color :"darkviolet", font: 20}, showarrow: false, yref: "y2"})
        }

        //ADD transcript 
        shapes.push({type: "line", x0: tr.txstart, x1: tr.txend, y0: middle, y1: middle, line_color: "black",yref: "y2"}) 
        //ADD exons
        tr.position.forEach(p => shapes.push({type: "rect", x0: p[0], x1: p[1], y0: middle - exonOffset, y1: middle + exonOffset ,
                                              fillcolor: "darkgrey", line: {color: "black" }, yref: "y2"}))
        //Strand info
        let strand_marker = tr.strand > 0 ? ">" : "<";
        let max_index = tr.position.length - 1
        let x_values = []
        let y_values = []
        let txStrand = tr.strand > 0 ? "+" : "-"
        let customData = []
        let markerOffset = showTranscripts ? 0.01 : 0.02;
        for (index in tr.position) {
            
            //Get x and y values for hover data
            let startPos = tr.position[parseInt(index)][0]
            let endPos = tr.position[parseInt(index)][1]

            x_values.push(startPos + ((endPos - startPos) / 2 ))
            y_values.push(middle)

            //Get hover data
            let gTxStart = gene.plot_coords.g[binary_search(gene.plot_coords.x, tr.txstart)]
            let gTxEnd = gene.plot_coords.g[binary_search(gene.plot_coords.x, tr.txend)]
            let gStartPos = gene.plot_coords.g[binary_search(gene.plot_coords.x, startPos)]
            let gEndPos = gene.plot_coords.g[binary_search(gene.plot_coords.x, endPos)]
            customData.push({"symbol": gene.symbol, "txStart": gTxStart, "txEnd": gTxEnd, "exonStart": gStartPos, "exonEnd": gEndPos, "strand": txStrand}) 

            //Get strand annotation text
            if (parseInt(index) == max_index) {
                break
            };

            let nextStartPos = tr.position[(parseInt(index) + 1)][0]
            let xPos = endPos + ((nextStartPos - endPos) / 2)

            strandArray.push({x: xPos, y: middle + markerOffset, text: strand_marker, font: {color: "black", size: 16}, opacity: 0.7, showarrow: false, yref: "y2"})
        };

        let trace = {x: x_values, y: y_values, 
                type: 'scatter', mode:'markers', customdata: customData, name: "Merged Transcript",
                opacity: 0.0,showlegend: false, yaxis: "y2", marker: { color: "skyblue", size: 15},
                hovertemplate: '<b>Gene</b>: %{customdata.symbol}<br><b>Strand</b>: %{customdata.strand}<br><b>TX Start</b>: %{customdata.txStart}<br><b>TX End</b>: %{customdata.txEnd}<br><b>Merged Exon Start</b>: %{customdata.exonStart}<br><b>Merged Exon End</b>: %{customdata.exonEnd}<br>',
            };

        return({"shapes":shapes, "strand_annotation":strandArray, "trace":trace})
    };


    function binary_search(A, v) {
        var result = 0;
        var j = A.length
        while (j != 0){
            let step = j >> 1
            let pos = result + step;
            if(A[pos] < v) {
              result = pos + 1
              j -= step + 1
            } else {
              j = step
            }

        }
        return result
    }


    //Get a map of transcript information to use as a custoomdata imput for plotly hover data
    function get_custom_data(transcript, exonStart, exonEnd, exonNumber, cdsExon, feature, xs, gposition_list ) {

        custdata = { "tx_id":  transcript.transcript,
                     "strand":  transcript.strand > 0 ? "+" : "-", 
                     "tx_start": gposition_list[binary_search(xs, transcript.txstart)] ,
                     "tx_end": gposition_list[binary_search(xs, transcript.txend)] ,
                     "cds_start": gposition_list[binary_search(xs, transcript.cdsstart)] ,
                     "cds_end": gposition_list[binary_search(xs, transcript.cdsend)] ,
                     "exon_start": gposition_list[binary_search(xs, exonStart)] ,
                     "exon_end": gposition_list[binary_search(xs, exonEnd)] ,
                     "exon_count": exonNumber,
                     "CDS": cdsExon,
                     "Feature": feature}

        return(custdata)

    }; 


    //Get UTR information/shape for a transcript 
    function getUTRInfo(gene, symbol, transcript, utrOffset, yValue, customData, shapes, x_values, y_values, text_symbol ) {

            //Get Start UTRs 
            let utr1 = {type: "rect", x0:transcript.txstart, x1:transcript.cdsstart, 
                        y0: yValue - utrOffset, y1: yValue + utrOffset,
                        line_color: "black", fillcolor: "cyan", yref: "y3"}


            //Get End UTR 
            let utr2 = {type: "rect", x0:transcript.cdsend, x1:transcript.txend, 
                        y0: yValue - utrOffset, y1: yValue + utrOffset,
                        line_color: "cyan", fillcolor: "cyan", yref: "y3"}


            // If CDS region is at the end of the transcript, the whole region is a UTR
            if (transcript.txend <= transcript.cdsstart) {

                //Add UTR info to customData
                ///UTR1
                customData.push(get_custom_data(transcript, transcript.txstart,
                transcript.cdsstart, "UTR", "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g))
                 text_symbol.push(symbol) 

                //Add UTRs to shapes
                ///UR1
                shapes.push(utr1)

                // Add UTR plot coordinates for hover info 
                ///UTR1
                x_values.push((transcript.txstart + ((transcript.cdsstart - transcript.txstart) / 2)))
                y_values.push(yValue)

            // IF CDS regions ends at the beginning of the transcript, the whole region is a UTR
            } else if (transcript.txstart >= transcript.cdsend) {

                //Add UTR info to customData
                ///UTR2
                customData.push(get_custom_data(transcript, transcript.cdsend,
                transcript.txend, "UTR", "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g)) 
                text_symbol.push(symbol) 

                //Add UTRs to shapes
                ///UTR2
                shapes.push(utr2)

                // Add UTR plot coordinates for hover info 
                ///UTR2
                x_values.push((transcript.cdsend + ((transcript.txend - transcript.cdsend) / 2)))
                y_values.push(yValue)

            } else {

                //Add UTR info to customData
                ///UTR1
                customData.push(get_custom_data(transcript, transcript.txstart,
                transcript.cdsstart, transcript.strand > 0 ? "5'-UTR" : "3'-UTR",
                "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g)) 
                text_symbol.push(symbol) 
                ///UTR2
                customData.push(get_custom_data(transcript, transcript.cdsend,
                transcript.txend, transcript.strand > 0 ? "3'-UTR" : "5'-UTR",
                "UTR", "UTR", gene.plot_coords.x, gene.plot_coords.g)) 
                text_symbol.push(symbol) 

                //Add UTRs to shapes
                ///UR1
                shapes.push(utr1)
                ///UTR2
                shapes.push(utr2)

                // Add UTR plot coordinates for hover info 
                ///UTR1
                x_values.push((transcript.txstart + ((transcript.cdsstart - transcript.txstart) / 2)))
                y_values.push(yValue)
                ///UTR2
                x_values.push((transcript.cdsend + ((transcript.txend - transcript.cdsend) / 2)))
                y_values.push(yValue)

            };

        return({"custData": customData, "shapeData": shapes, "xValues": x_values, "yValues":  y_values, "symbolArray": text_symbol})
    };


    //Get CDS Exons for a transcript
    function getCdsExons(gene, symbol, transcript, exon_2d_array, cdsExonCount, exonOffset, yValue, customData, shapes, x_values, y_values, text_symbol) {

        // Get exon numbers
        let exonNumbers = transcript.strand > 0 ? pv.range(1,cdsExonCount + 1) : pv.range(cdsExonCount, 0, -1) 
        let exonNumberOffset = 0

        //Add exon shapes
        for (index in exon_2d_array) {
            
            let exonPos = exon_2d_array[index]

            //If exon in CDS region
            if (exonPos[1] > transcript.cdsstart & exonPos[0] < transcript.cdsend) {

                //Get Exon Positions
                let exonStart = exonPos[0] > transcript.cdsstart ? exonPos[0] : transcript.cdsstart
                let exonEnd = exonPos[1] < transcript.cdsend ? exonPos[1] : transcript.cdsend

                //Add Shapes
                shapes.push({type: "rect", x0: exonStart, x1: exonEnd,  y0: yValue - exonOffset, 
                             y1: yValue +  exonOffset, line_color: "black", fillcolor: "black", yref: "y3"}) 

                //Get exon region info
                let feature = "Coding Exon" 
                let codingRegion = "True"
                if (exonStart != exonPos[0] | exonEnd != exonPos[1]) {
                    feature = "Partial Coding Exon"
                    codingRegion = "Partial"
                };

                //Add exon info to customData
                /// Add the full exon start and end position, even if the exon is partially in non-CDS region
                customData.push(get_custom_data(transcript, exonPos[0], exonPos[1], exonNumbers[(parseInt(index) - exonNumberOffset)], 
                                                codingRegion, feature, gene.plot_coords.x, gene.plot_coords.g)) 
                text_symbol.push(symbol) 

                // Add exon plot coordinates for hover info
                //If non-CDS exons are being shown, the hover x coordinate will change
                if (nonCdsChecked) {
                    //Check which coordinate, if any, are partial Non-CDS
                    if (exonStart != exonPos[0]) {
                        x_values.push(exonStart)

                    } else if (exonEnd != exonPos[1]) {
                        x_values.push(exonEnd)

                    } else {
                        x_values.push((exonStart + ((exonEnd - exonStart) / 2)))

                    };

                } else {
                    x_values.push((exonStart + ((exonEnd - exonStart) / 2)))

                };

                y_values.push(yValue)
            
            // If exon not in CDS region
            } else {
                exonNumberOffset += 1
            };
        };

        return({"custData": customData, "shapeData": shapes, "xValues": x_values, "yValues":  y_values, "symbolArray": text_symbol})
    };


    //Get Non-CDS Exons for a transcript
    function getNonCdsExons(gene, symbol, transcript, exon_2d_array, exonOffset, yValue, customData, shapes, x_values, y_values, text_symbol) {

        //Add exon shapes
        for (index in exon_2d_array) {
            
            let exonPos = exon_2d_array[index]

            //Skip any full CDS exon
            if (exonPos[0] >= transcript.cdsstart & exonPos[1] <= transcript.cdsend) {continue};
            
            //Get Exon Positions
            let exonStart = exonPos[0] 
            let exonEnd = exonPos[1] 
            let partialCds = false
            
            //Adjust start and end position if they overlap CDS region 
            /// IF exon start is before cds start and exon end is after, adjust end position
            if (exonPos[0] < transcript.cdsstart & exonPos[1] > transcript.cdsstart) {
                exonEnd = transcript.cdsstart
                partialCds = true
            };

            /// IF exon start is before cds end and exon end is after, adjust start position
            if (exonPos[0] < transcript.cdsend & exonPos[1] > transcript.cdsend) {
                exonStart = transcript.cdsend
                partialCds = true
            };

            //Add Shapes
            shapes.push({type: "rect", x0: exonStart, x1: exonEnd,  y0: yValue - exonOffset, 
                         y1: yValue +  exonOffset, opacity: 0.4,  line_color: "black", fillcolor: "grey", yref: "y3"}) 


            //Add exon info to customData
            /// Add the full exon start and end position, even if the exon is partially in non-CDS region
            if (!(partialCds)) {
                customData.push(get_custom_data(transcript, exonStart, exonEnd, "NA", "False", "Non-Coding Exon", 
                                                gene.plot_coords.x, gene.plot_coords.g)) 
                    text_symbol.push(symbol) 

                    x_values.push((exonStart + ((exonEnd - exonStart) / 2)))
                    y_values.push(yValue)
            };

        };

        return({"custData": customData, "shapeData": shapes, "xValues": x_values, "yValues":  y_values, "symbolArray": text_symbol})
    };
    

	//Get the transcript shapes for the current region
    function get_transcript_shapes(gene) {
        
        let symbol = gene.symbol
        let top = 10;
        let bottom = 8;
        let exonOffset = 0.25;
        let utrOffset = 0.1;
        let shapes = [];
        let tick_labels = [];
        let tick_vals = [];
        let strandArray = [];
        let x_values = []
        let y_values = []
        let customData = []
        let text_symbol = []

        for (transcript of gene.transcripts) {
            
            //Sort exon positions 
            exon_2d_array = transcript.position.sort(function(a,b) {return a[0] - b[0]})
            
            //Count cds exons
            let cdsExonCount = 0
            for (index in exon_2d_array) {

                let exonPos = transcript.position[index]

                if (exonPos[1] > transcript.cdsstart & exonPos[0] < transcript.cdsend) {cdsExonCount += 1};

            };

            //If neither UTRs or non-CDS Exons are being shown, and the CDS Exon Count is 0, skip this transcript. 
            if (utrsChecked | nonCdsChecked | cdsExonCount > 0) {

                // Transcript 
                shapes.push({type: "line", x0: transcript.txstart, x1: transcript.txend, 
                             y0: bottom + 1, y1: bottom + 1, line_color: "black",yref: "y3"}) 

                //Strand info
                let strand_interval = Math.round((transcript.txend - transcript.txstart) / 20)
                let strand_marker = transcript.strand > 0 ? ">" : "<";
                for (i = transcript.cdsstart; i < transcript.cdsend; i++) {
                    if (i % strand_interval == 0) {
                        strandArray.push({x: i, y: bottom + 1.01, text: strand_marker, font: {color: "black", size: 16}, opacity: 0.7, showarrow: false, yref: "y3"})
                    };
                };

            } else {continue};


            // Get exon numbers
            let exonNumbers = transcript.strand > 0 ? pv.range(1,cdsExonCount + 1) : pv.range(cdsExonCount, 0, -1) 
            let exonNumberOffset = 0

            //Get the CDS Exons
            let cdsExonMap = getCdsExons(gene, symbol, transcript, exon_2d_array, cdsExonCount, exonOffset, (bottom + 1), customData, shapes, x_values, y_values, text_symbol)
            
            //Update data objects with CDS Exon info
            customData = cdsExonMap.custData
            shapes = cdsExonMap.shapeData
            x_values = cdsExonMap.xValues
            y_values = cdsExonMap.yValues
            text_symbol = cdsExonMap.symbolArray

            //If UTR checkbox is true, add UTRs
            if (utrsChecked) {

                //Get UTR shapes
                let utrMap = getUTRInfo(gene, symbol, transcript, utrOffset, (bottom + 1), customData, shapes, x_values, y_values, text_symbol)
                
                //Update data objects with UTR info
                customData = utrMap.custData
                shapes = utrMap.shapeData
                x_values = utrMap.xValues
                y_values = utrMap.yValues
                text_symbol = utrMap.symbolArray

            };

            //Add non CDS exons if checked
            if (nonCdsChecked) {

                let nonCdsExonMap = getNonCdsExons(gene, symbol, transcript, exon_2d_array, exonOffset, (bottom + 1), customData, shapes, x_values, y_values, text_symbol)
                //Update data objects with CDS Exon info
                customData = nonCdsExonMap.custData
                shapes = nonCdsExonMap.shapeData
                x_values = nonCdsExonMap.xValues
                y_values = nonCdsExonMap.yValues
                text_symbol = nonCdsExonMap.symbolArray
            };

            //Get tick labels
            tick_labels.push(transcript.transcript)
            tick_vals.push(bottom + 1)

            //update bottom 
            bottom = bottom - 1 
        };

        //Add a trace for the hover info
        let trace = {x: x_values, y: y_values, text: text_symbol, 
                type: 'scatter', mode:'markers', customdata: customData, name: "Transcripts",
                opacity: 0.0, showlegend: false, yaxis: "y3", marker: { color: "darkcyan", size: 15},
                hovertemplate: '<b>Gene</b>: %{text}<br><b>Transcript ID</b>: %{customdata.tx_id}<br><b>Strand</b>: %{customdata.strand}<br><b>Feature</b>: %{customdata.Feature}<br><b>Start Position</b>: %{customdata.exon_start}<br><b>End Position</b>: %{customdata.exon_end}<br><b>Coding Region</b>: %{customdata.CDS}<br><b>CDS Exon Number</b>: %{customdata.exon_count}<br>',
            };

        return({"shapes": shapes, "top": top, "bottom": bottom, "tick_labels": tick_labels, "tick_vals": tick_vals, "strand_annotation": strandArray, "trace": trace})
    };

    //Get descriptive stats info for stats table
    function get_stats_table(gene, low_depth = 10) {

        var dataRows = []
        var columnNames = [{"title": "Sample", width: "20%"},
                           {"title": "Mean Depth", width: "10%"},
                           {"title": "Median Depth", width: "10%"},
                           {"title": "STD", width: "10%"},
                           {"title": "Min Depth", width: "10%"},
                           {"title": "Max Depth", width: "10%"},
                           {"title": "Low Coverage Sites<br>( <=" + low_depth + " )", width: "30%"}]
    
        for (sample in gene.plot_coords.depths) {

            // Depths 
            let dp = gene.plot_coords.depths[sample]
            dp = dp.filter(value => value > -1000);

            //Get depth descriptive statistics
            let dp_min = Math.min(...dp)
            let dp_max = Math.max(...dp)
            let dp_mean = math.round(math.mean(dp),3)
            let dp_median = math.median(dp)
            let dp_std = math.round(math.std(dp),3)
            let dp_low = math.sum(dp.map(function(v) { return v <= low_depth ? 1: 0})) 

            dataRows.push([sample, dp_mean, dp_median, dp_std, dp_min, dp_max, dp_low])
        };
        return({rowData: dataRows, colNames: columnNames})
    };


    //Get the traces for each sample depth distribution
    function get_depth_distribution_traces(gene) {

        let traces = []
        let group_min_dp = 1000
        let group_max_dp = 0

        for (sample in gene.plot_coords.depths) {

            // Depths 
            let dp = gene.plot_coords.depths[sample]

            //Convert null values to NaN 
            dp = dp.filter(value => value > -1000);

            //min and max 
            let dp_min = Math.min(...dp)
            group_min_dp = dp_min < group_min_dp ? dp_min : group_min_dp
            let dp_max = Math.max(...dp)
            group_max_dp = dp_max > group_max_dp ? dp_max : group_max_dp

            // X and Y values
            let x_values = pv.range(dp_min,dp_max+1)
            let y_values = new Array(x_values.length).fill(0)

            //Get y values
            //index of depth in x_values = depth - dp_min
            dp.forEach(depth => y_values[(depth - dp_min)] += 1)


            let trace = {x: x_values, y: y_values,  mode: "lines", 
                         name: sample, line: {width: 1}, 
                         hovertemplate: "<b>Depth</b>:%{x}<br><b>Count</b>:%{y}"}

            traces.push(trace)
        };
        
        return({"traces":traces, "min":group_min_dp, "max":group_max_dp})

    };


    //Get the depth distribution layout
    function get_depth_distribution_layout(xaxis_min=0,xaxis_max=100) {

        var layout = {
            autosize: true,
            title: "Depth Distribution per Sample",
            xaxis: {
                title: "Depth",
                range: [xaxis_min,xaxis_max]
            },
            yaxis: {
                title: "Count",
                domain: [0.0,0.9],
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                xanchor: "right",
                yanchor: "top",
                y: 1,
                x: 1,
                orientation: "h",
                borderwidth: 1,
                bordercolor: '#eeeeee'
            },
        };
        return(layout)
    };


    //per Sample depth proportion traces
    function get_proportion_trace(gene) {

        let traces = []

        for (sample in gene.plot_coords.depths) {

            // Depths 
            dp = dp.filter(value => value > -1000);

            let depth_map = {}
            let depth_values = new Set()
            let dp_count = 0 
            //get the number of 
            for (depth of dp) {
                
                dp_count += 1
                
                depth_values.add(depth)

                if (!(depth in depth_map)) {
                    depth_map[depth] = 1

                } else {
                    depth_map[depth] += 1
                };
            };

            let x_values = []
            let y_values = []
            let counter = 0
            //Calculate proportion scores
            for (key of [...depth_values].sort(function(a,b) {return b-a})) {

                //increment counter
                counter += depth_map[key]

                //Add x and y valuess
                x_values.push(key)
                y_values.push(counter / dp_count)

            };

            let trace = {x: x_values, y: y_values,  mode: "lines", 
                         name: sample, line: {width: 1}, 
                         hovertemplate: "<b>Depth</b>:%{x}<br><b>Proportion</b>:%{y}"}

            traces.push(trace)
        };
        
        return(traces)
    };


    //by proprotion plot layout
    function get_proportion_layout() {

        var layout = {
            autosize: true,
            title: "Depth Proportion per Sample",
            xaxis: {
                title: "Depth"
            },
            yaxis: {
                title: "Proportion",
                domain: [0.0,0.9],
            },
            hovermode: 'closest',
            showlegend: true,
            legend: {
                xanchor: "right",
                yanchor: "top",
                y: 1,
                x: 1,
                orientation: "h",
                borderwidth: 1,
                bordercolor: '#eeeeee'
            },
        };
        return(layout)
    };
    

    /*
    ------------------------------------------------------------------------------------------------------------------
                                                     Plot Controllers 
    ------------------------------------------------------------------------------------------------------------------
    */

    //Per base depth plot with transcript annotations
    function plot_per_base_depth(gene) {

        //Get gene specific layout
        plot_gene_layout = get_gene_plot_layout(gene)

        //Get gene specific depth traces
        by_position_depth_traces = get_by_position_depth_trace(gene)

        // get unionized transcript shapes
        unioned_transcript_shapes = get_unioned_transcript_shapes(gene)
        by_position_depth_traces.push(unioned_transcript_shapes.trace)
        
        //If show transcripts is turned on, who the transcript plot
        if (showTranscripts) {
            // Get per transcript annotation shapes
            transcript_map = get_transcript_shapes(gene)
            by_position_depth_traces.push(transcript_map.trace)

            //Add shapes to layout 
            plot_gene_layout.shapes = unioned_transcript_shapes.shapes.concat(transcript_map.shapes)

            //Adjuste subplot 3 yaxis ranges based on the number of annotated  transcripts 
            plot_gene_layout.yaxis3.range = [transcript_map.bottom, transcript_map.top]

            //Add subplot 3 yaxis tick labels (transcript ids)
            plot_gene_layout.yaxis3.tickvals = transcript_map.tick_vals
            plot_gene_layout.yaxis3.ticktext = transcript_map.tick_labels

            //Add subplot 3 strand annotations 
            plot_gene_layout.annotations = transcript_map.strand_annotation.concat(unioned_transcript_shapes.strand_annotation)


        } else {

            //Add shapes to layout 
            plot_gene_layout.shapes = unioned_transcript_shapes.shapes
            plot_gene_layout.annotations = unioned_transcript_shapes.strand_annotation

        };

        //Plot by base depth 
        Plotly.newPlot("gene_plot", by_position_depth_traces, plot_gene_layout)

    };


    //Add a jQuery data table with descriptive stats
    function plot_stats_table(gene) {

        //Remove previous data table if it exists
        if ($.fn.DataTable.isDataTable('#stats_table')) {
            let table = $('#stats_table').DataTable()
            table.destroy();
        };

        //Get row data and column names
        rows_and_columns = get_stats_table(gene)

        //Create data table
        jQuery("#stats_table").DataTable({
            destory: true,
            data: rows_and_columns["rowData"],
            columns: rows_and_columns["colNames"],
            paging: true,
            scroller: true,
            scrollY: '60vh',
            scrollX: true,
            scrollCollapse: true,
            select: {style: "os"},
        });

    };


    //Depth Distribution plot using per depth count 
    function plot_depth_distribution(gene) {

        //Get depth distribution plot trace per sample 
        var depth_map = get_depth_distribution_traces(gene)

        //Get the plot layout for the depth plot
        var depth_dist_layout = get_depth_distribution_layout(depth_map.min - 5, depth_map.max + 5)

        Plotly.newPlot("depth_dist_plot", depth_map.traces, depth_dist_layout)

    };



    /*
    ------------------------------------------------------------------------------------------------------------------
                                                     Event Handling 
    ------------------------------------------------------------------------------------------------------------------
    */

    //Controller function for generating gene/region sepecific plots
    function generate_plots(selected_region) {

        //Index of plot in plot_data and gene data
        var plotIndex = region_index_map[selected_region];
        var selectedGene = plot_data[plotIndex];

        //Update region specific header  
        var header = document.getElementById("region_header")
        header.innerHTML = selected_region

        //Update gene description 
        var description = document.getElementById("gene_description")
        description.innerHTML = selectedGene.description

        //Plot per base depths 
        plot_per_base_depth(selectedGene)

        //Add a descriptive statistics table
        plot_stats_table(selectedGene)

        //Plot depth distribution distrubtion 
        plot_depth_distribution(selectedGene)
        
    };


    //Load first region
    jQuery(document).ready(function(){

        //Plot first gene
        for (region in region_index_map){
            if (region_index_map[region] == initalIndex) {
                currentRegion = region
                generate_plots(region)
                break
            };
        };

    });


    //Select gene/region change
    $("#regionselect").on('change', function(e) {
        var selectedValue = this.value

        //Set the Current Region
        currentRegion = selectedValue

        //Plot the selected region
        generate_plots(selectedValue)

    });


    //Turn on or off UTR regions in the transcript plot
    $("#utrs").on('change', function(e) {
        
        utrsChecked = this.checked
    
        //Redraw per base depth plot
        //Index of plot in plot_data and gene data
        var plotIndex = region_index_map[currentRegion];
        var selectedGene = plot_data[plotIndex];

        //Plot per base depths 
        plot_per_base_depth(selectedGene)

    });


    //Turn on or off Non-CDS Exons in the transcript plot
    $("#nonCdsExons").on('change', function(e) {
        
        nonCdsChecked = this.checked

        //Redraw per base depth plot
        //Index of plot in plot_data and gene data
        var plotIndex = region_index_map[currentRegion];
        var selectedGene = plot_data[plotIndex];

        //Plot per base depths 
        plot_per_base_depth(selectedGene)

    });

    //Turn on and off the transcript plot
    $("#showTranscripts").click(function() {

        //Update bool value for transcripts
        showTranscripts = !(showTranscripts)

        // Update button text
        // Update div class
        if (showTranscripts) {
            $(this).text("Hide Transcripts")
            document.getElementById("gene_plot").className = "big_div";
        } else {
            $(this).text("Show Transcripts")
            document.getElementById("gene_plot").className = "med_div";
        };

        //Redraw per base depth plot
        //Index of plot in plot_data and gene data
        var plotIndex = region_index_map[currentRegion];
        var selectedGene = plot_data[plotIndex];

        //Plot per base depths 
        plot_per_base_depth(selectedGene)

    });

    

</script>

</body>
</html>
